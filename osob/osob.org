* Особенность выполнения арифметических операций в ВМ
** Обработка переполнения разрядной сетки

Выполнение арифм. операций операндов с разрядностью n:

- сложение -> n+1
- умножение -> 2n


Происходит =переполнение разрядной сетки=.

- CF - Carry Flag

  В флаг который переносится знак числа

  C1 - фиксирует перенос единицы из старшего разряда значащей части
  числа в знаковый разряд

  С2 - фиксирует наличие переноса единицы из знакового разряда в CF
- OF - Overflow Flag

  Хранит переполнение разрядной сетки

  $OF = C1 \oplus C2$

  if (OF == 1) CF Хранить значащую часть результата



Пример:

[[./images/1.png]]

Переполнение не произошло, результат: $0_z111_2 = 0_z7_{10}$

Пример 2:

[[./images/2.png]]

Имеет место переполнение разрядной сетки в CF находится знак
результата. В знаковом разряде находится старший разряд значащей
части числа. В разрядной сетке результата некорректный
результат: $0_z1011_2 = 0_z11_{10}$


# TODO: добавить картиночки
Пример 3:

Имеет место переполнение разрядной сетки в CF находится знак
числа. В знаковом разряде находится старший разряд значащей
части числа. В разрядной сетке результата некорректный
результат: $(1_0101_2)_{dop} = (1_z1011_2)_{pr} =  0_z11_{10}$

Пример 4:


Переполнения нет. CF игнорируем.
В разрядной сетке корректный результат.
** Сложение чисел в формате с плавающей точкой

[[./images/3.png]]

6.56 \cdot 10^5 + 1.25 \cdot 10^3 = 656 \cdot 10^3 + 1.25 \cdot 10 ^ 3
= 657.25 \cdot 10^3
*** Алгоритм сложения в формате с плавающей точкой

1. Если порядки операндов различаются, выполняется
   выравнивание порядков. При этом мантисса операндов
   меньших порядков сдвигается вправо с учётом целой части
   на каждом шаге сдвига порядок увеличивается на один. Сдвиги
   выполняются до тех пор, пока порядки слагаемых не станут равными.
2. Мантиссы складываются по алгоритму алгоритмического сложения
3. Порядок результата приравнивается порядку слагаемых
4. Мантисса результата нормализуется
5. Если разряды разные, то они заполняются незначащими нулями  

